#region Using declarations
using System;
using System.Net.Http;
using System.Text;
using NinjaTrader.Cbi;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
#endregion

namespace NinjaTrader.NinjaScript.Strategies
{
    public class TurtleV4 : Strategy
    {
        // ===== DISCORD =====
        private const string DISCORD_WEBHOOK_URL =
            "https://discordapp.com/api/webhooks/1449953862331924600/lfjbW-9EpmJZP709VGGm5eeZVeXM9kRFq6NPGyuahQnD1VAdDbz1USlwrZQWOB2MawJs";

        private static readonly HttpClient http = new HttpClient();

        private async void SendDiscord(string msg)
        {
            try
            {
                var json = "{\"content\":\"" + msg.Replace("\"", "'") + "\"}";
                var content = new StringContent(json, Encoding.UTF8, "application/json");
                await http.PostAsync(DISCORD_WEBHOOK_URL, content);
            }
            catch { }
        }

        // ===== RISK SETTINGS =====
        private const double RiskTarget = 500.0;
        private const double RiskHardCap = 550.0;
        private const int BEPlusTicks = 1;
        private const int BreakBufferTicks = 1;

        // ===== STATE =====
        private DateTime lastDay = Core.Globals.MinDate;
        private double dailyPnL = 0;
        private bool dayHalted = false;

        private string sessionKey = "";
        private int sessionTrades = 0;

        private DateTime orbStart;
        private DateTime orbEnd;
        private double orbHigh;
        private double orbLow;
        private bool orbDefined;

        private bool inTrade = false;
        private bool halfTaken = false;
        private double entryPrice = 0;

        private double tickSize;
        private double tickValue;

        private string uid = "";

        protected override void OnStateChange()
        {
            if (State == State.SetDefaults)
            {
                Name = "TurtleV4";
                Calculate = Calculate.OnBarClose;
                EntriesPerDirection = 2;
                EntryHandling = EntryHandling.AllEntries;
                IsOverlay = true;
                IncludeCommission = true;
            }
            else if (State == State.Configure)
            {
                tickSize = Math.Max(TickSize, 0.0000001);
                tickValue = GetTickValue(Instrument.MasterInstrument.Name);

                string sym = Instrument.MasterInstrument.Name;
                string acct = Account != null ? Account.Name.Replace(" ", "") : "NOACCT";
                uid = "_" + sym + "_" + acct;
            }
        }

        // ===== TICK VALUES =====
        private double GetTickValue(string instrument)
        {
            instrument = instrument.ToUpper();
            if (instrument.StartsWith("M6E")) return 0.625;
            if (instrument.StartsWith("MNQ")) return 0.50;
            if (instrument.StartsWith("MGC")) return 1.00;
            if (instrument.StartsWith("MES")) return 1.25;
            return Instrument.MasterInstrument.PointValue * tickSize;
        }

        // ===== SESSION FILTER =====
        private bool InSession(DateTime t, out string key, out DateTime open)
        {
            key = "";
            open = DateTime.MinValue;
            int h = t.Hour;
            int m = t.Minute;

            if (h >= 20 && h < 22)
            {
                key = "ASIA_" + t.Date;
                open = new DateTime(t.Year, t.Month, t.Day, 20, 0, 0);
                return true;
            }
            if (h >= 3 && h < 5)
            {
                key = "LONDON_" + t.Date;
                open = new DateTime(t.Year, t.Month, t.Day, 3, 0, 0);
                return true;
            }
            if ((h == 9 && m >= 30) || h == 10 || (h == 11 && m < 30))
            {
                key = "NY_" + t.Date;
                open = new DateTime(t.Year, t.Month, t.Day, 9, 30, 0);
                return true;
            }
            return false;
        }

        // ===== RISK CALC =====
        private int ContractsForRisk(double stopDist)
        {
            double ticks = Math.Abs(stopDist / tickSize);
            double riskPer = ticks * tickValue;

            if (riskPer <= 0 || riskPer > RiskHardCap)
                return 0;

            int qty = (int)Math.Floor(RiskTarget / riskPer);
            if (qty < 1) qty = 1;

            while (qty * riskPer > RiskHardCap)
                qty--;

            return qty;
        }

        protected override void OnBarUpdate()
        {
            if (CurrentBar < 20)
                return;

            if (Time[0].Date != lastDay.Date)
            {
                lastDay = Time[0].Date;
                dailyPnL = 0;
                dayHalted = false;
                sessionTrades = 0;
                orbDefined = false;
                inTrade = false;
                halfTaken = false;
            }

            if (dayHalted)
                return;

            string key;
            DateTime open;
            if (!InSession(Time[0], out key, out open))
                return;

            if (key != sessionKey)
            {
                sessionKey = key;
                sessionTrades = 0;
                orbStart = open;
                orbEnd = open.AddMinutes(15);
                orbHigh = double.MinValue;
                orbLow = double.MaxValue;
                orbDefined = false;
            }

            if (sessionTrades >= 2 || inTrade)
                return;

            if (Time[0] >= orbStart && Time[0] < orbEnd)
            {
                orbHigh = Math.Max(orbHigh, High[0]);
                orbLow = Math.Min(orbLow, Low[0]);
                return;
            }

            if (!orbDefined && Time[0] >= orbEnd)
                orbDefined = true;

            if (!orbDefined)
                return;

            double buffer = BreakBufferTicks * tickSize;

            bool longBreak = Close[0] > orbHigh + buffer;
            bool shortBreak = Close[0] < orbLow - buffer;

            if (Position.MarketPosition != MarketPosition.Flat)
                return;

            if (longBreak)
            {
                double stop = orbLow;
                double dist = Close[0] - stop;
                int qty = ContractsForRisk(dist);
                if (qty < 1) return;

                int q1 = qty / 2;
                int q2 = qty - q1;
                if (q1 == 0) { q1 = 1; q2 = 0; }

                int rTicks = (int)Math.Round(dist / tickSize);

                SetStopLoss("LE1" + uid, CalculationMode.Price, stop, false);
                SetStopLoss("LE2" + uid, CalculationMode.Price, stop, false);
                SetProfitTarget("LE1" + uid, CalculationMode.Ticks, rTicks);
                SetProfitTarget("LE2" + uid, CalculationMode.Ticks, rTicks * 2);

                EnterLong(q1, "LE1" + uid);
                if (q2 > 0) EnterLong(q2, "LE2" + uid);

                entryPrice = Close[0];
                inTrade = true;
                halfTaken = false;
                sessionTrades++;
            }

            if (shortBreak)
            {
                double stop = orbHigh;
                double dist = stop - Close[0];
                int qty = ContractsForRisk(dist);
                if (qty < 1) return;

                int q1 = qty / 2;
                int q2 = qty - q1;
                if (q1 == 0) { q1 = 1; q2 = 0; }

                int rTicks = (int)Math.Round(dist / tickSize);

                SetStopLoss("SE1" + uid, CalculationMode.Price, stop, false);
                SetStopLoss("SE2" + uid, CalculationMode.Price, stop, false);
                SetProfitTarget("SE1" + uid, CalculationMode.Ticks, rTicks);
                SetProfitTarget("SE2" + uid, CalculationMode.Ticks, rTicks * 2);

                EnterShort(q1, "SE1" + uid);
                if (q2 > 0) EnterShort(q2, "SE2" + uid);

                entryPrice = Close[0];
                inTrade = true;
                halfTaken = false;
                sessionTrades++;
            }
        }

        protected override void OnExecutionUpdate(Execution exec, string id, double price, int qty,
            MarketPosition pos, string orderId, DateTime time)
        {
            if (exec == null || exec.Order == null || exec.Order.OrderState != OrderState.Filled)
                return;

            dailyPnL = 0;
            foreach (Trade t in SystemPerformance.AllTrades)
                if (t.Exit != null && t.Exit.Time.Date == Time[0].Date)
                    dailyPnL += t.ProfitCurrency;

            if (State == State.Realtime)
            {
                SendDiscord($"TurtleV4 | {Instrument.FullName} | {exec.Order.Name} | Qty {qty} | Price {price}");
            }

            if (!halfTaken)
            {
                if (exec.Order.FromEntrySignal == "LE1" + uid && Position.MarketPosition == MarketPosition.Long)
                {
                    halfTaken = true;
                    SetStopLoss("LE2" + uid, CalculationMode.Price,
                        entryPrice + BEPlusTicks * tickSize, false);

                    if (State == State.Realtime)
                        SendDiscord($"TurtleV4 TP1 HIT → BE | {Instrument.FullName}");
                }

                if (exec.Order.FromEntrySignal == "SE1" + uid && Position.MarketPosition == MarketPosition.Short)
                {
                    halfTaken = true;
                    SetStopLoss("SE2" + uid, CalculationMode.Price,
                        entryPrice - BEPlusTicks * tickSize, false);

                    if (State == State.Realtime)
                        SendDiscord($"TurtleV4 TP1 HIT → BE | {Instrument.FullName}");
                }
            }

            if (Position.MarketPosition == MarketPosition.Flat)
            {
                inTrade = false;
                halfTaken = false;

                if (State == State.Realtime)
                    SendDiscord($"TurtleV4 EXIT | DailyPnL: {dailyPnL:C}");
            }
        }
    }
}
